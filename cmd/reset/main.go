package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type resetStruct struct {
	Name   string
	Fields []resetField
}

type resetField struct {
	Name string
	Expr ast.Expr
}

type pkgInfo struct {
	Package string
	Structs []resetStruct
}

const tmplText = `// Code generated by reset generator; DO NOT EDIT.
package {{.Package}}

{{range .Structs}}
func (r *{{.Name}}) Reset() {
	if r == nil {
		return
	}
{{range .Fields}}
{{resetFunc .}}
{{end}}
}
{{end}}
`

var tmpl = template.Must(template.New("reset").Funcs(template.FuncMap{
	"resetFunc": func(f resetField) string {
		return genResetForExpr("r."+f.Name, f.Expr)
	},
}).Parse(tmplText))

func main() {
	root := "."

	pkgs := map[string]*pkgInfo{}

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}

		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		dir := filepath.Dir(path)
		pkg, ok := pkgs[dir]
		if !ok {
			pkg = &pkgInfo{Package: file.Name.Name}
			pkgs[dir] = pkg
		}

		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}

			hasTag := false
			if genDecl.Doc != nil {
				for _, c := range genDecl.Doc.List {
					if strings.Contains(c.Text, "generate:reset") {
						hasTag = true
						break
					}
				}
			}
			if !hasTag {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				var fields []resetField
				if structType.Fields != nil {
					for _, field := range structType.Fields.List {
						if len(field.Names) == 0 {
							continue
						}
						for _, nameIdent := range field.Names {
							fields = append(fields, resetField{
								Name: nameIdent.Name,
								Expr: field.Type,
							})
						}
					}
				}

				pkg.Structs = append(pkg.Structs, resetStruct{
					Name:   typeSpec.Name.Name,
					Fields: fields,
				})
			}
		}

		return nil
	})

	if err != nil {
		log.Fatalf("walk error: %v", err)
	}

	for dir, info := range pkgs {
		if len(info.Structs) == 0 {
			continue
		}

		data := map[string]interface{}{
			"Package": info.Package,
			"Structs": info.Structs,
		}

		buf := &bytes.Buffer{}
		if err := tmpl.Execute(buf, data); err != nil {
			log.Printf("template exec: %v", err)
			continue
		}

		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			log.Printf("format error for %s: %v\n", dir, err)
			continue
		}

		outFile := filepath.Join(dir, "reset.gen.go")
		if err = os.WriteFile(outFile, formatted, 0644); err != nil {
			log.Printf("write %s: %v", outFile, err)
			continue
		}
		log.Println("Generated:", outFile)
	}
}

func genResetForExpr(receiverExpr string, expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		typ := t.Name
		if isPrimitive(typ) {
			return fmt.Sprintf("%s = %s\n", receiverExpr, zeroValue(typ))
		}
		return fmt.Sprintf("if resetter, ok := interface{}(&%s).(interface{ Reset() }); ok {\nresetter.Reset()\n}\n", receiverExpr)
	case *ast.StarExpr:
		return genResetForPointer(receiverExpr, t.X)
	case *ast.ArrayType:
		return fmt.Sprintf("%s = %s[:0]\n", receiverExpr, receiverExpr)
	case *ast.MapType:
		return fmt.Sprintf("clear(%s)\n", receiverExpr)
	default:
		return ""
	}
}

func genResetForPointer(receiverExpr string, baseExpr ast.Expr) string {
	switch base := baseExpr.(type) {
	case *ast.Ident:
		baseName := base.Name
		if isPrimitive(baseName) {
			return fmt.Sprintf("if %s != nil {\n*%s = %s\n}\n", receiverExpr, receiverExpr, zeroValue(baseName))
		}
		return fmt.Sprintf("if resetter, ok := %s.(interface{ Reset() }); ok && %s != nil {\nresetter.Reset()\n}\n", receiverExpr, receiverExpr)
	case *ast.ArrayType:
		return fmt.Sprintf("if %s != nil {\n*%s = (*%s)[:0]\n}\n", receiverExpr, receiverExpr, receiverExpr)
	case *ast.MapType:
		return fmt.Sprintf("if %s != nil {\nclear(*%s)\n}\n", receiverExpr, receiverExpr)
	default:
		return ""
	}
}

func isPrimitive(t string) bool {
	switch t {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"uintptr",
		"float32", "float64",
		"complex64", "complex128",
		"byte", "rune",
		"string", "bool":
		return true
	default:
		return false
	}
}

func zeroValue(t string) string {
	switch t {
	case "string":
		return `""`
	case "bool":
		return "false"
	case "byte", "rune":
		return "0"
	default:
		return "0"
	}
}
