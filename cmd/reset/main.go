package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type resetStruct struct {
	Name   string
	Fields []resetField
}

type resetField struct {
	Name string
	Expr ast.Expr
}

type pkgInfo struct {
	Package string
	Structs []resetStruct
}

const tmplText = `// Code generated by reset generator; DO NOT EDIT.
package {{.Package}}

{{range .Structs}}
func (r *{{.Name}}) Reset() {
	if r == nil {
		return
	}
{{range .Fields}}
{{resetFunc .}}
{{end}}
}
{{end}}
`

var tmpl = template.Must(template.New("reset").Funcs(template.FuncMap{
	"resetFunc": func(f resetField) string {
		return genResetForExpr("r."+f.Name, f.Expr)
	},
}).Parse(tmplText))

func main() {
	pkgs, err := collectPackages(".")
	if err != nil {
		log.Fatalf("collect packages: %v", err)
	}

	generateResetFiles(pkgs)
}

func collectPackages(root string) (map[string]*pkgInfo, error) {
	pkgs := map[string]*pkgInfo{}

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !shouldProcessFile(path) {
			return nil
		}

		pkg, err := processFile(path, pkgs)
		if err != nil {
			return err
		}

		if pkg != nil {
			dir := filepath.Dir(path)
			pkgs[dir] = pkg
		}

		return nil
	})

	return pkgs, err
}

func shouldProcessFile(path string) bool {
	return strings.HasSuffix(path, ".go") && !strings.HasSuffix(path, "_test.go")
}

func processFile(path string, pkgs map[string]*pkgInfo) (*pkgInfo, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	dir := filepath.Dir(path)
	pkg, ok := pkgs[dir]
	if !ok {
		pkg = &pkgInfo{Package: file.Name.Name}
	}

	structs := extractResetStructs(file)
	pkg.Structs = append(pkg.Structs, structs...)

	return pkg, nil
}

func extractResetStructs(file *ast.File) []resetStruct {
	var structs []resetStruct

	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		if !hasResetTag(genDecl) {
			continue
		}

		for _, spec := range genDecl.Specs {
			if s := extractStructFromSpec(spec); s != nil {
				structs = append(structs, *s)
			}
		}
	}

	return structs
}

func hasResetTag(genDecl *ast.GenDecl) bool {
	if genDecl.Doc == nil {
		return false
	}
	for _, c := range genDecl.Doc.List {
		if strings.Contains(c.Text, "generate:reset") {
			return true
		}
	}
	return false
}

func extractStructFromSpec(spec ast.Spec) *resetStruct {
	typeSpec, ok := spec.(*ast.TypeSpec)
	if !ok {
		return nil
	}

	structType, ok := typeSpec.Type.(*ast.StructType)
	if !ok {
		return nil
	}

	fields := extractFields(structType)

	return &resetStruct{
		Name:   typeSpec.Name.Name,
		Fields: fields,
	}
}

func extractFields(structType *ast.StructType) []resetField {
	var fields []resetField

	if structType.Fields == nil {
		return fields
	}

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}
		for _, nameIdent := range field.Names {
			fields = append(fields, resetField{
				Name: nameIdent.Name,
				Expr: field.Type,
			})
		}
	}

	return fields
}

func generateResetFiles(pkgs map[string]*pkgInfo) {
	for dir, info := range pkgs {
		if len(info.Structs) == 0 {
			continue
		}

		if err := generateResetFile(dir, info); err != nil {
			log.Printf("generate %s: %v", dir, err)
		} else {
			log.Printf("Generated: %s/reset.gen.go", dir)
		}
	}
}

func generateResetFile(dir string, info *pkgInfo) error {
	data := map[string]interface{}{
		"Package": info.Package,
		"Structs": info.Structs,
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, data); err != nil {
		return fmt.Errorf("template exec: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format: %w", err)
	}

	outFile := filepath.Join(dir, "reset.gen.go")
	if err := os.WriteFile(outFile, formatted, 0644); err != nil {
		return fmt.Errorf("write: %w", err)
	}

	return nil
}

func genResetForExpr(receiverExpr string, expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		typ := t.Name
		if isPrimitive(typ) {
			return fmt.Sprintf("%s = %s\n", receiverExpr, zeroValue(typ))
		}
		return fmt.Sprintf("if resetter, ok := interface{}(&%s).(interface{ Reset() }); ok {\nresetter.Reset()\n}\n", receiverExpr)
	case *ast.StarExpr:
		return genResetForPointer(receiverExpr, t.X)
	case *ast.ArrayType:
		return fmt.Sprintf("%s = %s[:0]\n", receiverExpr, receiverExpr)
	case *ast.MapType:
		return fmt.Sprintf("clear(%s)\n", receiverExpr)
	default:
		return ""
	}
}

func genResetForPointer(receiverExpr string, baseExpr ast.Expr) string {
	switch base := baseExpr.(type) {
	case *ast.Ident:
		baseName := base.Name
		if isPrimitive(baseName) {
			return fmt.Sprintf("if %s != nil {\n*%s = %s\n}\n", receiverExpr, receiverExpr, zeroValue(baseName))
		}
		return fmt.Sprintf("if resetter, ok := %s.(interface{ Reset() }); ok && %s != nil {\nresetter.Reset()\n}\n", receiverExpr, receiverExpr)
	case *ast.ArrayType:
		return fmt.Sprintf("if %s != nil {\n*%s = (*%s)[:0]\n}\n", receiverExpr, receiverExpr, receiverExpr)
	case *ast.MapType:
		return fmt.Sprintf("if %s != nil {\nclear(*%s)\n}\n", receiverExpr, receiverExpr)
	default:
		return ""
	}
}

func isPrimitive(t string) bool {
	switch t {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"uintptr",
		"float32", "float64",
		"complex64", "complex128",
		"byte", "rune",
		"string", "bool":
		return true
	default:
		return false
	}
}

func zeroValue(t string) string {
	switch t {
	case "string":
		return `""`
	case "bool":
		return "false"
	case "byte", "rune":
		return "0"
	default:
		return "0"
	}
}
